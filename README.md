# Задание 3

Мобилизация.Гифки – сервис для поиска гифок в перерывах между занятиями.

Сервис написан с использованием [bem-components](https://ru.bem.info/platform/libs/bem-components/5.0.0/).

Работа избранного в оффлайне реализована с помощью технологии [Service Worker](https://developer.mozilla.org/ru/docs/Web/API/Service_Worker_API/Using_Service_Workers).

Для поиска изображений используется [API сервиса Giphy](https://github.com/Giphy/GiphyAPI).

В браузерах, не поддерживающих сервис-воркеры, приложение так же должно корректно работать, 
за исключением возможности работы в оффлайне.

## Структура проекта

  * `gifs.html` – точка входа
  * `assets` – статические файлы проекта
  * `vendor` –  статические файлы внешних библиотек
  * `service-worker.js` – скрипт сервис-воркера

Открывать `gifs.html` нужно с помощью локального веб-сервера – не как файл. 
Это можно сделать с помощью встроенного в WebStorm/Idea веб-сервера, с помощью простого сервера
из состава PHP или Python. Можно воспользоваться и любым другим способом.

# Решение

1. Из названия «Разложить файлы красиво» можно сделать вывод, что сервис воркер перенесли в assets. Но в этой папке его scope ограничен (_Максимальная видимость сервис-воркера равна его location_), о чем свидетельствует последняя описанная проблема. Следовательно, переносим файл service-worker.js в корень.

2. Правим пути:
- в assets/block.js путь к сервис воркеру;
- путь к kv-keeper в самом service-worker.js.

3. Для того, чтобы обновить статику из директорий vendor и assets, поменяем ``const CACHE_VERSION`` на любое другое значение => начнет работать удаление неактуального кэша.

4. Указываем gifs.js в needStoreForOffline, т.к. он не скачивался для оффлайн доступа и поэтому не загружался при отсутствии сети:
`` cacheKey.endsWith('gifs.html') ``

5. Теперь всё берется всегда из кэша: ``cacheResponse => cacheResponse``. Уберем это и поменяем на ``response = fetchAndPutToCache(cacheKey, event.request)``.

6. Проблема с обновлением страницы в онлайн-режиме решена.

## Дополнительное задание

1. Создал список файлов, которые требуется кэшировать URLS_TO_CACHE.

2. Сделал добавление в кэш на этапе install:
``assetsToCache``

3. Сделал список закэшированных ресурсов

## Ответы на вопросы в serive-worker:

1. Зачем нужен вызов self.skipWaiting()?
- Активирует установленный, но еще ожидающий Service Worker.

2. Зачем нужен вызов self.clients.claim()?
- Позволяет активному Service Worker установить себя, как активного для клиентской страницы.

3. Для всех ли случаев подойдёт такое построение ключа ``const cacheKey = url.origin + url.pathname``?
- Да, если нет параметров запроса. Иначе ещё нужно добавить url.search.toString();

4. Зачем нужна цепочка вызовов в deleteObsoleteCaches?
- Здесь происходит очистка кэша. Сперва фильтруется кэш, чтобы не попала текущая версия, затем удаляются неактуальные версии.

5. Для чего нужно клонирование?
- Клон помещается в кеш, а оригинальный ответ передается браузеру, который передает его странице, которая запросила ресурс.